// Code generated by go-bindata.
// sources:
// cf/i18n/resources/de_DE.all.json
// cf/i18n/resources/en_US.all.json
// cf/i18n/resources/es_ES.all.json
// cf/i18n/resources/fr_FR.all.json
// cf/i18n/resources/it_IT.all.json
// cf/i18n/resources/ja_JA.all.json
// cf/i18n/resources/pt_BR.all.json
// cf/i18n/resources/zh_Hans.all.json
// cf/i18n/resources/zh_Hant.all.json
// cf/i18n/test_fixtures/en_US.all.json
// cf/i18n/test_fixtures/fr_FR.all.json
// cf/i18n/test_fixtures/zh_Hans.all.json
// cf/i18n/test_fixtures/zh_Hant.all.json
// DO NOT EDIT!

package resources

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"strings"
	"os"
	"time"
	"io/ioutil"
	"path/filepath"
)

func bindataRead(data []byte, name string) ([]byte, error) {
	gz, err := gzip.NewReader(bytes.NewBuffer(data))
	if err != nil {
		return nil, fmt.Errorf("Read %q: %v", name, err)
	}

	var buf bytes.Buffer
	_, err = io.Copy(&buf, gz)
	clErr := gz.Close()

	if err != nil {
		return nil, fmt.Errorf("Read %q: %v", name, err)
	}
	if clErr != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name string
	size int64
	mode os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

